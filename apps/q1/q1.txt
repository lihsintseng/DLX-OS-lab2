1. There are 32 max semaphores, and 64 max locks.
2. The system calls to create, acquire and release a lock are lock_create(), lock_acquire(lock_t k) and lock_release(lock_t ) respectively. 
3. It is created using sem_create(int count). The integer "count" is used to specify the counter in the semaphore which the user creates. The function first find an avaliable semaphore in the system then it initials the counter in the semaphore. After making sure that the semaphore waiting queue is initialized, it return the handle to the newest created semaphore.
4. lock_acquire first checks if the lock is valid and is not in-used. Then it disables interrupts and checks that the process does not already own a lock. After that, the process tries to acquire the lock. If other process is using the lock, the original process goes to the waiting queue and sleep. Otherwise, the lock is assigned to the process. Then it restores the interrupt.
The first few steps of lock_release are similar to lock_acquire. It first check if the lock is valid and is not in-used. Then it disables interrupts and checks that the process does not already own a lock. After the lock is released by the current process, the next process in the waiting queue would get the lock and restore the interrupt.
sem_wait is used to check if the resources of a semaphore are used. When the value of the semaphore is equal to 0, it means that all the resources are used, and the process must wait for the resources to become available. Once the wait ends, the value of the semaphore will be decremented by one.
sem_signal is used by a process to state that it finishes the usage of the resource of a semaphore and it will increment the semaphore's value.
5. A handle is a pointer to a semaphore and it allows the same semaphore to be accessed between different processes.
